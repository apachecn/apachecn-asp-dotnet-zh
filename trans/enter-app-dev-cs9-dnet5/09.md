# *第 9 章*:处理数据。NET 5

任何 web 应用程序的基本组件之一是将数据保存到永久数据存储中的能力；在选择合适的持久存储时，一些预先考虑可以帮助系统在未来更好地扩展。

任何 web 应用程序中常见的操作之一是登录到系统，执行一些读取/更新，然后注销，然后稍后再回来查看更改是否被保留。数据库在保持这些操作(通常称为用户事务)方面起着重要作用。除了事务数据之外，出于监控和调试的目的，应用程序可能还需要存储日志数据和审计数据，例如谁修改了日期。设计任何此类应用程序的一个重要步骤是理解需求并相应地设计数据库。根据各种数据保留要求和任何数据保护政策选择/设计数据库也很重要，例如**通用数据保护条例** ( **GDPR** )。

一个应用可以有多个数据提供者，如**结构化查询语言** ( **SQL** )数据提供者、NoSQL 数据提供者、文件数据提供者等等。在本章中，我们将讨论可用于中的存储和数据处理的各种数据提供程序。NET 5。我们将涵盖以下主题:

*   数据介绍
*   磁盘、文件和目录
*   SQL、天青宇宙数据库和天青存储
*   与英孚核心合作
*   使用 Azure 宇宙数据库设计数据访问服务

# 技术要求

对…的基本了解。NET Core、C#、Azure 和。NET 命令行界面是必需的。

本章的代码文件可以在以下链接中找到:[https://github . com/PacktPublishing/Enterprise-Application-Development-with-C-Sharp-9-and-。NET-5/树/主/第 09 章](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-Sharp-9-and-.NET-5/tree/master/Chapter09)。

代码的使用说明可以在这里找到:[https://github . com/PacktPublishing/Enterprise-Application-Development-with-C-Sharp-9-and-。NET-5/树/主/企业% 20 应用程序](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-Sharp-9-and-.NET-5/tree/master/Enterprise%20Application)

# 数据介绍

任何网络应用程序，无论是内容管理系统、社交网络平台还是电子商务应用程序，都需要将数据保存到永久存储中，以便用户可以根据需要检索、消费和处理数据。在 [*第八章*](08.html#_idTextAnchor156)*理解缓存*中，我们讨论了使用缓存存储；但是，缓存存储是临时存储，数据仍然需要保存到永久存储中。所以，我们需要一个不只是支持不同实体上各种 **CRUD** (简称**创建/读取/更新/删除**)操作，还支持高可用性，并在宕机时恢复任何数据的存储，也就是灾难恢复。

更好的系统设计的关键标准之一是在系统的早期阶段设计一个数据模型。数据模型应该尝试定义系统运行所需的所有可能的实体，并在各种实体之间进行交互。在系统设计的早期定义数据模型有助于确定如何管理数据和可以使用什么数据存储的正确策略，并有助于决定各种复制/分区策略。

下面几节将解释两种常见的分类数据存储。

## 关系数据库管理系统

关系数据库将数据存储在表中。每个实体被定义为一个或多个表，并且使用多个表来定义数据库。将表分隔成多个表的过程称为**规范化**。各种表之间的关系由外键约束定义。实体的属性定义为列，相同类型的多个实体存储为行。一些常用的关系数据库是微软的 SQL Server、MySQL、Postgres 和 Oracle。

存储员工信息的典型关系数据库可能有一个定义员工各种属性的`employee`表，如姓名、员工标识等，以及以员工标识为主键的列。多个员工作为单独的行存储在该表中。员工的任何属性都可以进一步规范化到单独的表中；例如，员工的项目可以存储在一个单独的表中(因为可以有多个项目)，例如`employeeproject`，并且可以使用员工标识链接到员工表，如下图所示:

![Figure 9.1 – Employee ER diagram ](Images/Figure_9.1_B15927.jpg)

图 9.1–员工 ER 图

以下是关系数据库的几个关键特征:

*   使用 SQL 查询关系数据库。
*   表大多有定义良好的模式和约束，不太可能改变。
*   所有事务都具有 **ACID** (原子性/一致性/隔离性/持久性的缩写)属性，因此保持了数据的完整性和一致性。
*   随着数据的规范化，冗余被最小化。
*   关系数据库通常支持垂直扩展，也就是向上扩展(它们确实支持复制，但是与 NoSQL 数据库中的复制相比，这是一个昂贵的操作)。

## NoSQL

另一种数据存储是 NoSQL 数据库，它以非结构化格式存储数据，其中数据不需要有预定义的模式。最常见的情况是，数据要么存储为键值对(如在 Redis 中)，要么存储为文档(如在 MongoDB 和 CouchDB 中)，要么存储为使用图形结构的图形(如在 Neo4j 中)。

如果我们以同一个雇员为例，并将其保存在 NoSQL 数据库(如 MongoDB)中，我们最终会将其存储在一个类似`employee`的集合中，每个文档都存储该雇员的所有属性，如下所示:

```
{
  "employee": [
    {
      "employeeid": 1,
      "name": "Ravindra",
      "salary": 100,
      "Projects": [
        {
          "id": 1,
                  "name": "project1",
        },
        {
                     "id": 2,
                  "name": "project2",
        }
      ]
    }
  ]
}
```

以下是 NoSQL 数据库的几个关键特征:

*   实体不一定需要支持固定的模式，在任何时间点，都可以添加额外的属性。
*   它们非常适合非结构化数据，例如，将位置存储在拼车应用程序中。
*   与关系数据库相比，它们可以以低得多的成本轻松支持水平扩展。
*   数据高度冗余；然而，这极大地提高了性能，因为无需跨表执行连接就可以轻松获得数据。

Azure Cosmos DB 就是这样一个云管理的 NoSQL 数据库，我们将在我们的电子商务应用程序中将其用作数据存储。

任何存储平台的核心基础存储介质都是进一步存储在磁盘中的文件。让我们看看中提供的各种 API。NET 5，执行创建和修改文件和目录等操作。

# 磁盘、文件和目录

在计算机中，一个文件只不过是一组使用唯一名称引用的数据。比如所有员工的详细信息都可以分组存储在一个名为`employees`的文件中，每当我们需要查看员工数据时，我们都会打开`employees`文件搜索该数据。这是从一个类比中得出的，如果我们想以非数字形式保存所有员工的详细信息，我们将把它们写在纸上，把所有的文件钉在一起，并保存在一个文件中。

磁盘只不过是存储文件的存储介质。根据前面的类比，磁盘可以比作可以存储文件的机架。磁盘应该支持的一个关键点是管理文件、组织文件、定义文件的属性的方法，例如创建/修改文件的时间、在磁盘上查找可用空间的能力等等。这就是文件系统发挥作用的地方，它通常与操作系统一起出现，并包含管理磁盘上文件的这些方面。文件系统实现这一点的一种方法是使用目录。

现在让我们看看中的各种 API。NET 5，它允许我们与文件、磁盘和目录交互。

## 处理目录

目录或文件夹是文件分组的一种方式，是文件系统定义的一种规则组织文件和子目录。英寸 NET 5 中，我们在框架中提供了与文件系统通信和组织目录的 API。这些类主要是`System.IO`命名空间的一部分，有两个类主要用于对目录执行各种操作:

*   **目录** : `System.IO.Directory`是一个静态类，公开了各种方法允许我们创建目录，查询目录属性，移动等等。当我们需要执行简单的目录操作时，这个类很有用。
*   **目录信息** : `System.IO.DirectoryInfo`是另一个可以用来对目录/文件夹进行各种操作的类；然而，这不是一个静态类，因此需要这个类的一个对象来调用各种方法。更重要的是，这个类提供了一些高级方法，比如在一个工作目录中创建子目录。因此，如果我们需要递归地对单个目录执行操作，可以使用这个类。

让我们创建一个简单的控制台应用程序，如果目录不存在，就创建一个目录，并列出目录的各种属性。我们还将创建一些文件并(在下一节中详细讨论)枚举它们，然后最后删除目录。

我们还将使用`System.Environment`、`System.IO.Path`和`System.IO.DriveInfo`类来显示与环境、当前驱动器和当前文件夹相关的一些常规属性。那么，让我们来看看怎么做:

1.  使用 Visual Studio 2019 或创建控制台应用程序。NET 命令行界面。
2.  Update the `Main` class with the following code:

    ```
    static void Main(string[] args)
            {
                string currentDriveLetter = Path.GetPath
                Root(System.Reflection.Assembly.
                GetEntryAssembly().Location);
                DriveInfo di = new DriveInfo(current
                DriveLetter);
                if (di.IsReady) // Checking if drive is 
                                // ready
                {
                    Console.WriteLine($"Available space 
                    in {currentDriveLetter} is 
                    {di.AvailableFreeSpace.ToString()}");
                }
                Console.WriteLine($"Current location 
                (using Environment class) – 
                {Environment.CurrentDirectory}");
                Console.WriteLine($"Current location 
                (using path class)- {Path.
                GetFullPath(Environment.
                CurrentDirectory)}");
                string newDirectoryName = "New Data 
                Directory";
                if (Directory.Exists(newDirectoryName))
                {
                    Console.WriteLine($"Directory with 
                    name {newDirectoryName} already 
                    exists!!");
                }
                else
                {
                    Directory.CreateDirectory(
                    newDirectoryName);
                    Console.WriteLine($"Directory 
                    {newDirectoryName} created!!");
                }
            }
    ```

    在前面的代码中，我们正在执行以下操作:

    *   使用`Path`类获取当前驱动器的路径
    *   使用`DriveInfo`类显示当前驱动器中的可用空间
    *   如果目录不存在，则创建目录
3.  接下来，在目录创建代码之后，将以下代码添加到`Main`方法中。在这段代码中，我们正在执行以下操作:
    *   使用`DirectoryInfo`类创建子目录。
    *   使用`System.IO.File`静态类创建几个空文件，然后枚举这些文件，显示它们的一些属性。
    *   最后，删除创建的文件夹。参考以下代码:

        ```
                    DirectoryInfo dirInfo = new DirectoryInfo(
                    newDirectoryName);
                    dirInfo.CreateSubdirectory($"Sub 
                    {newDirectoryName}");
                    //Create few files and enumerate.
                    for (int i = 0; i < 5; i++)
                    {
                        FileStream fs = File.Create(Path.
                        Combine(Environment.CurrentDirectory, 
                        newDirectoryName, $"File {i}"));
                        fs.Dispose();
                    }
                    foreach (FileInfo fi in dirInfo.GetFiles())
                    {
                        Console.WriteLine($"File {fi.Name} 
                        created on - {fi.CreationTime.
                        TimeOfDay}, Size: {fi.Length}");
                    }
                    dirInfo.Delete(true);// clean up, passing 
                    //true to recursively delete contents.
                    Console.WriteLine("Directory deleted!!");
        ```

4.  一旦我们运行这段代码，我们将看到以下输出:

![Figure 9.2 – Directory operations output ](Images/Figure_9.2_B15927.jpg)

图 9.2–目录操作输出

如果您打开 Windows 资源管理器，在删除目录之前查看目录的中间内容，它将如下所示:

![Figure 9.3 – Files in the directory ](Images/Figure_9.3_B15927.jpg)

图 9.3–目录中的文件

如你所见。NET 5 自带了很多 API，允许我们对目录执行各种操作。在下一节中，让我们浏览一下可用于对文件执行类似操作的各种 API。

## 用流、二进制和字符串读取/写入数据

。NET 5 自带了大量的 API 来读写文件中的数据，从静态的`System.IO.File`类到基于实例的类，比如`System.IO.FileInfo`。然而，在进入可以对文件进行操作的应用编程接口之前，我们应该了解什么是流。

英寸 NET 5，一个流只不过是一个来自存储的字节序列。底层存储/设备，也称为后备存储，可以是文件、内存或对应用编程接口(网络)的响应。流的概念主要是提供一个抽象，这样应用程序就不需要知道后备存储。每当应用程序需要读取一些数据时，它将使用可以从流中读取的 API，并且当它需要更新该数据时，它将更新该流。然后，该流将进一步将其传递给后备存储。

## 溪流

流在从文件中读取/写入数据时很有用。英寸 NET 5，支持从流中读取和向流中写入的类是`System.IO.Stream`，它是一个抽象类，有三个重要的方法:

*   `Read/ReadAsync`:同步和异步从流中读取数据
*   `Write/WriteAsync`:将数据同步和异步写入流
*   `Seek`:接受整数值，并将流中的当前位置移动到指定值

由于`Stream`类是抽象类，。NET 5 附带了一些具体的实现，如下图所示:

![Figure 9.4 – Stream hierarchy ](Images/Figure_9.4_B15927.jpg)

图 9.4–流层次结构

让我们创建一个方法，并使用`FileStream`类的一个对象来读取和写入数据到一个文件。我们将使用静态`File`类的`Create`方法，然后使用`OpenRead`方法读取文件的内容。

创建控制台应用程序并添加以下方法:

```
        static async Task ReadStreamAsync()
        {
            byte[] writeData = new byte[5] { 80, 65, 67, 75
            , 84 };
            UTF8Encoding temp = new UTF8Encoding(true);
            string data = "PACKT";
            Encoding.ASCII.GetBytes(data);
            using (Stream fs = File.Create("WriteDataUsing
            FileStream.txt"))
            {
                await fs.WriteAsync(writeData); 
                //String PACKT in ASCII   
                byte[] readData = new byte[5];
                fs.Position = 0; // Setting the stream 
                                 //position to 0.
                int chunkRed = 0, dataRed = 0;
                while ((chunkRed = fs.Read(readData,
                dataRed, readData.Length – 
                chunkRed)) > 0)
                {
                    dataRed += chunkRed;
                }                
                for (int i = 0; i < readData.Length; i++)
                    Console.Write(readData[i]);
            }
```

一旦我们在控制台应用程序中调用这个方法，我们可以看到已经创建了一个名为`WriteDataUsingFileStream.txt`的文本文件，该文件的内容将是`PACKT`字符串。现在，流的`Read`方法不能保证它将读取大小计数参数的整个数据(在前面的示例中为`readData.Length`)，因此我们需要依赖于`Read`方法返回的值，该值只不过是已处理的数据流的大小。然而，在前面的代码中，控制台上的输出仍然以字节为单位，即`80, 65, 97, 75, 84,`，这就是编码和解码的作用。

编码是将字符转换成字节的一种方式，同样，解码也是将字节转换成字符的一种方式。这里，在示例中，我们需要对字节数组进行解码，以便将内容转换为字符，并以可读的格式显示。英寸 NET 5，这可以通过使用`System.Text.Encoding`类来实现。在前面的代码中，按照如下方式更改`Console.WriteLine`并运行应用程序:

```
Console.Write($"{Encoding.ASCII.GetString(readData)}");
```

这次你可以看到输出是`PACKT`。

## 读者/作者

大多数现实世界的应用程序会处理可读性更强的字符串、XML/JSON 数据或该语言支持的任何其他数据类型，而不是字节，尽管在前面的示例中，我们可以用一行代码将字节数组转换为字符串，但随着编码类型的不同，如 ASCII、UTF-8 等，它会变得更加复杂。这就是原因。NET 5 附带了读取器和写入器类，它们可以与流对话，并根据需要转换数据。这些类主要充当适配器，抽象底层流，然后将流转换为所需的类型。一般来说，读者/作家类。NET 5 如下图所示:

![Figure 9.5 – Reader/writer (adapter) hierarchy ](Images/Figure_9.5_B15927.jpg)

图 9.5–读取器/写入器(适配器)层次结构

让我们了解这些是什么:

*   `StreamReader/StreamWriter`:抽象类`TextReader/TextWrite`的具体实现，对流进行操作，将它们转换成字符/字符串，反之亦然
*   `StringReader/StringWriter`:具体实现`TextReader/TextWriter`抽象类对内存中的字符串进行操作，例如字符串操作或者对大字符串段落中的行数进行计数
*   `BinaryReader/BinaryWriter`:从流中读取和向流中写入的具体类，专门将 int 和 Boolean 等原始数据类型转换为流，反之亦然
*   `XmlReader/XmlWriter`:将流转换为 XML 的具体类，反之亦然

有了这个的理解，让我们创建一个简单的控制台应用程序，我们将使用`StreamWriter`将数据写入文件，然后使用`StreamReader`读取数据，使用`StringWriter`和`StringReader`对内容重新排序，并显示它:

1.  创建一个控制台应用程序，并添加以下将字符串内容写入文件的方法:

    ```
            static async Task UsingStreamReaderWriter()
            {
           // Create a string array with the lines of text
                string[] lines = { "This is the First line
                ", "This is the Second line", 
                "This is the Third line" };
                // Write the string array to a new file 
                //named "WriteLines.txt".
                using (StreamWriter outputFile = new 
                StreamWriter("WriteLinesUsingSW.txt"))
                {
                    foreach (string line in lines)
                    {
                        await outputFile.WriteLineAsync
                        (line);
                    }
                }
                Console.WriteLine("File write completed 
                using StreamWriter\n");
            }
    ```

2.  将以下代码添加到`UsingStreamReaderWriter`方法中，在该方法中，我们正在读取之前使用`StreamReader`创建的文件。此外，这里我们还利用`StringWriter`将其附加写入字符串。当然，这里我们也可以利用`StringBuilder`类；然而，如果有一个场景，我们需要将它传递给另一个接受`TextReader`类型实例的方法，在这种情况下，`StringReader`会派上用场:

    ```
                StringBuilder sb = new StringBuilder();
                StringWriter srw = new StringWriter();
                using (StreamReader sr = new StreamReader
                ("WriteLinesUsingSW.txt"))
                {
                    Console.WriteLine(sr.BaseStream.Length
                    ); // Using base stream to 
                    //retrieve length of file contents.
                    while (!sr.EndOfStream)
                    {
                        string line = sr.ReadLine();
                        srw.Write($"{line}\n"); 
    // Appending . at the end of line for easy 
    //separate later
                    }
                }
                Console.WriteLine("Reading from 
                StringWriter");
                Console.WriteLine(srw.ToString());
    ```

3.  最后，添加以下代码，它与文件内容相反，并打印它。由于文件内容已经在`StringWriter`对象中可用，我们将把它读入一个`StringReader`对象，并使用`StringReader`的方法生成最终输出:

    ```
                using (StringReader str = new 
                StringReader(srw.ToString()))
                {
                    while (str.Peek() > -
                    1) // Peeking to check end of string
                    {
                        char currentCharacter = Convert.
                        ToChar(str.Read());
                        if (currentCharacter != '\n') 
    //Checking current character and inserting at the 
    //beginning of string builder
                           sb.Insert(0, currentCharacter);
                        else
                           sb.Insert(0, '.');
                    }
                }
                if (srw != null)
                    srw.Dispose();
                Console.WriteLine("Reading from 
                Stringbuilder aftere reversal");
                Console.WriteLine(sb.ToString());
    ```

4.  然后，我们在主方法中调用这个并执行控制台应用程序。输出将如下图所示，同时在相同的位置创建`WriteLinesUsingSW.txt`文件:

![Figure 9.6 – Reader/writer output ](Images/Figure_9.6_B15927.jpg)

图 9.6–读取器/写入器输出

`StreamWriter`使用的默认编码是 UTF-8；但是，有一个参数化的构造函数允许您指定编码。在`StreamReader`的情况下。NET 5 在内部尝试检测流的编码并相应地使用它。然而，如果它不能检测到源的编码，它将回落到 UTF-8。

一般来说，如果给一个选择，我们应该使用一个使用更少字节来存储数据的编码，重要的是，它应该支持你数据中的所有字符。

## 文本阅读器/文本编写器与二进制阅读器/二进制编写器

一般来说，存储在计算机中的任何东西只不过是一系列 0 或 1 的位，因此所有东西都以二进制形式存储。然而，存储为二进制的文件和二进制或文本的文件内容是有区别的。例如，文本文件的内容可以是文本数据；但是，JPEG 文件不能表示为文本，并且大多数情况下，它将以二进制形式表示。正确的读写器库用于合适的文件是非常重要的。下表给出了各种适配器之间的一些差异:

![Table 9.1 ](Images/012.jpg)

表 9.1

我们对 C#中可用的各种类的讨论到此结束，这些类可用于写入文件、从文件中读取以及处理目录。让我们简单讨论一下 C#中最常用的序列化库。

## JSON。净得很

任何关于文件读/写的讨论如果不涉及 JSON.NET 库都是不完整的，该库是用于将对象序列化为 JSON 的最常见的库，反之亦然。正如我们所知，JSON 是 **JavaScript 对象符号**，也是交换数据的公认标准。关键思想是能够保存/传输(序列化)对象的状态，以便可以在稍后阶段以相同的形式检索(反序列化)。

使用 JSON.NET 序列化数据最简单的方法是使用`JsonConvert`静态类并调用方法，如以下代码片段所示:

```
    // Type
    public class Employee
    {
        public string Name { get; set; }
        public int Id { get; set; }
    }
    // Usage  
    Employee employee = new Employee
    {
                Name = "John",
                Id = 1
    };        
    // Serialize
    File.WriteAllText("employee.json", JsonConvert.
    SerializeObject(employee));
   // Deserialize
var output = JsonConvert.DeserializeObject<Employee>(File.ReadAllText("employee.json"));
```

虽然从。NET Core 3.0 之后，微软推出了一个名为`System.Text.Json`的新库，用于序列化和反序列化对象；正如在 [*第 8 章*](08.html#_idTextAnchor156)*中开发的`Packt.Ecommerce.Caching`项目一样，理解* *缓存*，我们将使用`System.Text.Json`进行我们的电子商务应用，除非我们遇到这里提到的一些问题:[https://github.com/dotnet/runtime/issues?q=system.text.json](https://github.com/dotnet/runtime/issues?q=system.text.json)。所有可用的 api 都可以在这里找到:[https://docs . Microsoft . com/en-us/dotnet/API/system . text . JSON？view=net-5.0](https://docs.microsoft.com/en-us/dotnet/api/system.text.json?view=net-5.0) 。

到目前为止，我们已经看到了如何在中可用的文件和目录以及各种 API 上进行操作。NET 5。然而，更多的时候，应用程序不是直接写入文件系统，而是写入一个抽象了文件系统复杂性的数据库系统。让我们看看其中的一些提供者以及它们与。NET 5。

# SQL、Azure 宇宙数据库和 Azure 存储

之前，我们讨论了将数据存储分为关系数据库和 NoSQL 的更广泛的分类。在本节中，让我们详细了解微软生态系统中可用的一些数据提供者及其与的集成。NET 5。提供者种类繁多，包括 SQL、Azure Cosmos DB、Azure Storage 等，数据提供者的选择完全由应用需求驱动。然而，在现实生活中，应用程序的需求会发生很大的变化，因此关键是用业务层和用户界面来抽象数据框架的实现，这进一步有助于根据需要改进设计。接下来，让我们在下一节中看看我们的第一个数据提供者，SQL。

## SQL Server

关系数据库管理系统市场中占主导地位的数据库之一是微软 SQL Server，俗称 SQL Server，它使用 SQL 与数据库进行交互。SQL Server 支持所有基于关系数据库管理系统的实体，例如表、视图、存储过程和索引等，并且主要在 Windows 环境下工作。但是，从 SQL Server 2017 开始，它同时支持 Windows 和 Linux 环境。

SQL Server 的主要组件是它的数据库引擎，它负责处理查询和管理文件中的数据。除了数据库引擎之外，SQL Server 还附带了各种数据管理工具，例如:

*   **SQL Server 管理工作室** ( **SSMS** ):连接到 SQL Server 并执行操作，如创建数据库、监控数据库、查询数据库和备份数据库
*   **SQL Server 集成服务** ( **SSIS** ):用于数据集成和转换
*   **SQL Server 分析服务** ( **SSAS** ):用于数据分析
*   **SQL Server 报告服务** ( **SSRS** ):用于报告和可视化

要在本地计算机上配置 SQL Server，我们需要安装安装数据库引擎和一个或多个前面组件的 SQL Server 版本之一。安装通常包括下载安装程序并通过图形用户界面或命令行安装。有关安装的更多详细信息，请参考 https://docs . Microsoft . com/en-us/SQL/database-engine/install-windows/install-SQL-server？view=sql-server-ver15。

虽然在内部，但是 SQL Server 已经被广泛使用；管理数据库、升级等总会有开销这也是微软推出 Azure SQL 的地方，Azure SQL 是一个完全托管的 **PaaS** (简称**平台即服务**)组件，运行在与内部 SQL Server 相同的数据库引擎上。

Azure SQL 附带以下变体:

*   **Azure SQL 数据库(单个数据库)**:这是一个托管数据库服务器允许你用专用资源创建一个完全隔离的数据库。
*   **Azure SQL Database(弹性池)**:弹性池允许您在单个服务器上的预定义资源池(就 CPU、内存和 I/O 而言)中运行多个单个数据库。它是拥有多个数据库的企业的理想选择混合了低使用率和高使用率。在这种情况下使用弹性池的优点是，需要更多 CPU 使用的数据库可以在高需求期间利用它，并在低需求时释放它。使用弹性池的理想情况是当有一组数据库并且它们的消耗不可预测时。每当您看到一个数据库持续消耗相同的资源集时，它就可以从弹性池中移出，进入单个数据库，反之亦然。
*   **Azure SQL 托管实例**:该模型提供了一种将内部 SQL 基础架构无缝迁移到 Azure SQL 的方法，而无需重新架构内部应用程序，并允许您利用 PaaS。这非常适合于拥有庞大的内部数据库基础架构并且需要迁移到云而没有太多运营开销的应用程序。
*   **SQL Server on VM (Windows/Linux)**: SQL VMs come under the **Infrastructure as a Service** (**IaaS**) category and are very similar to on-premises SQL Server, only that VMs are on Azure instead of your local network.

    小费

    建议安装 SSMS，以便在 SQL Server(内部或云)上执行各种操作，因为它支持所有数据库操作。

从. NET 5 应用程序的角度来看，连接到 Azure SQL 与连接到内部 SQL Server 是一样的。可以使用 ADO.NET，我们使用`System.Data.SqlClient`导入，然后使用`SqlConnection`对象连接到 SQL，然后使用`SqlCommand`对象执行 SQL 查询，使用`SQLReader`类返回值。除此之外，我们可以使用**对象关系映射器** ( **ORM** )如**实体框架核心** ( **EF 核心**)来处理 Azure SQL，这将在*处理 EF 核心*一节中讨论。

所以，在这个部分，我们已经简单介绍了 Azure SQL。但是，我建议在这里查看Azure SQL 的所有功能:[https://docs.microsoft.com/en-us/azure/azure-sql/](https://docs.microsoft.com/en-us/azure/azure-sql/)。

至此，让我们继续讨论 Azure Cosmos DB，这是我们的电子商务应用程序将用作持久存储的数据库。

## 蓝色宇宙 DB

Azure Cosmos DB 是一个完全托管(PaaS)的 NoSQL、全球分布式和高度可扩展的数据库。Azure Cosmos DB 的一个关键之处是它的多模型特性，这有助于使用不同的 API 模型(如 SQL、MongoDB 和 Gremlin)传递各种格式的数据，如 JSON 和 BSON。开发人员可以灵活地使用他们熟悉的应用编程接口查询数据库。例如，SQL 开发人员可以继续使用 SQL 查询语法查询数据库，MongoDB 开发人员可以继续使用 MongoDB 语法查询数据库，等等。在引擎盖下，Azure Cosmos DB 以名为**Atom-Record-Sequence**(**ARS**)的格式存储数据库，并根据数据库创建过程中选择的模式将数据作为 API 公开。

Azure Cosmos DB 的另一个重要特点是它能够自动索引所有数据，并且独立于所使用的 API 模型。所有这些都无需开发人员另外创建索引，因此能够更快地检索数据。

Azure Cosmos DB 支持以下 API 来对数据库执行操作，这是我们在创建数据库时选择的:

*   **核心(SQL) API** :这是可以用来查询数据库的默认 API；查询会有一个 JSON 中输入/输出格式的 SQL 查询的语法。使用核心 SQL 应用编程接口的典型查询如下所示:`SELECT * FROM product WHERE product.Name = ' Mastering enterprise application development Book'`。
*   **MongoDB API** :这个 API 建立在 MongoDB 的有线协议上，可以与 MongoDB 客户端 SDK、驱动和工具无缝集成。该应用编程接口非常适合已经与 MongoDB 集成并迁移到 Azure Cosmos DB 的应用程序，或者非常适合开发人员已经习惯 MongoDB 查询语言的团队。这个 API 的最新版本支持 MongoDB 服务器 3.6 版本，Azure Cosmos DB 和 Mongo API 之间的典型查询连接将如下所示:`db.product.find({"Name": ' Mastering enterprise application development Book'})`。就像 MongoDB 一样，数据在 BSON 表示。
*   **Gremlin(图形)API** :该 API 支持使用 Gremlin 语言以图形格式查询和遍历数据。这非常适合数据可以以图形的形式表示，并且可以通过它们之间的关系进行查询的情况。一个典型的例子是推荐引擎，它可以建立两个实体之间的关系，并提出一个推荐。

除此之外，还有卡珊德拉应用编程接口，它使用卡珊德拉查询语言对数据库进行操作，然后是表应用编程接口，它可以被构建在 Azure 表存储之上的应用程序用作它们的数据存储。

正如你所看到的，有相当多的应用编程接口，更多的应用编程接口正在被添加。选择合适的 API 完全取决于应用需求；但是，以下几点可用于缩小选择范围:

*   如果是一个新的应用程序，那么就用核心应用编程接口。
*   如果它是一个建立在 NoSQL 上的现有应用程序，请根据底层数据存储选择相关的 API。例如，如果现有的数据库是 MongoDB，选择 Mongo API 等等。
*   对于处理特定的场景，比如建立数据之间的关系，使用 Gremlin API。

对于我们的企业应用程序，由于我们是从头开始构建这个应用程序，我们将使用核心(SQL)应用编程接口作为我们与 Azure Cosmos DB 交互的应用编程接口。

让我们先创建一个简单的控制台应用程序，并在 Azure Cosmos DB 上执行一些操作，稍后我们将在构建我们的数据访问服务时重用这些概念:

1.  首先，我们需要有一个 Azure Cosmos DB 帐户，所以登录 Azure 门户，点击**创建资源**，选择**数据库** | **Azure Cosmos DB** 。
2.  This will open the **Create Azure Cosmos DB Account** page. Fill in the details as shown in the following screenshot and click **Review + create**. This is the page where we select the API we want to choose, which is the Core (SQL) API in our case:

    ![Figure 9.7 – Create Azure Cosmos DB Account page ](Images/Figure_9.7_B15927.jpg)

    图 9.7–创建 Azure 宇宙数据库帐户页面

3.  一旦账户被创建，导航到**蔚蓝公司烟雾数据库账户** | **键**。复制 **URI** 和**主键**值。
4.  打开命令行，使用以下命令创建控制台应用程序:

    ```
    dotnet new console –output EcommerceSample
    ```

5.  导航到`EcommerceSample`文件夹，使用以下命令安装 Azure Cosmos DB SDK】
6.  打开`Program.cs`并将以下静态变量添加到`Program`类，该类将保存在*步骤 3* 中复制的 **URI** 和**主键**值:

    ```
     private static readonly string Uri = "YOUR URI HERE";
     private static readonly string PrimaryKey = 
    "YOUR PRIMARY KEY HERE";
    ```

7.  现在，让我们添加代码来创建一个`CosmosClient`类的对象，并使用它来创建一个 Azure Cosmos DB 数据库。随后，该对象将用于与我们的 Azure Cosmos DB 数据库进行通信。当`CosmosClient`实现`IDisposable`时，我们将在`using`块内创建它，以便在`using`块后自动处理该对象。运行此代码并导航到 Azure 门户中的 **Azure Cosmos 资源** | **数据资源管理器**后，可以看到将创建一个名为`Ecommerce`的数据库。由于我们已经使用核心(SQL)应用编程接口创建了 Azure Cosmos DB 帐户，该数据库将支持 SQL 语法查询:

    ```
    using (CosmosClient cosmosClient = new CosmosClient(Uri,
     PrimaryKey))
    {
     DatabaseResponse createDatabaseResponse
    = await cosmosClient.CreateDatabaseIfNotExistsAsync
    ("ECommerce");
     Database database = createDatabaseResponse.Database;
    }
    ```

8.  Now, let's create a container that is analogous to a table in SQL by adding the following code after `createDatabaseResponse`. As we are using `CreateDatabaseIfNotExistsAsync` to create the database, running the same code will not cause any exceptions. Once we run this code, we can see in the Azure portal that a container with the name `Products` is created under the `Ecommerce` database:

    ```
    var containerProperties = new ContainerProperties
    ("Products", "/Name");
    var createContainerResponse = await database.CreateContainerIfNotExistsAsync(containerProperties, 
    10000); var productContainer = createContainerResponse.
    Container;
    ```

    在前面的代码中，我们在创建容器的时候传递了`ContainerProperties`，可以看到其中一个值就是`Name`，无非就是一个分区键。

分区是 Azure Cosmos DB 的关键特性之一，它根据分区键将容器内的数据分隔成多个逻辑分区。使用分区键，Azure Cosmos DB 实现了数据库的水平扩展，从而满足了应用程序的可伸缩性和性能需求。选择分区键是一个关键的设计决策，因为它将极大地帮助数据库扩展和更好地运行。此外，分区键不能更改，必须在创建容器时定义。选择分区键时，请记住以下几点:

*   应该具有最大数量的唯一值；唯一值的数量越多，分区就越好。例如，如果我们正在为产品创建容器，产品标识或名称可能是分区键，因为这两个属性可以唯一地标识大多数产品。在兜帽下，如果为分区键选择了一个产品名称，并且内部有 100 个产品，则它在 Azure Cosmos DB 中由 100 个逻辑容器表示。这里，产品类别也可以是一个分区键，但是在选择它作为分区键之前，我们需要评估样本数据并根据需求来决定。
*   If there is no obvious unique choice, we can pick the most used field in the filtering query, so basically, a column that is very often used in the `where` clause.

    小费

    在现实应用中，应该使用 ARM 模板来实现 Azure Cosmos DB 帐户的创建，以便模板可以轻松地与**连续部署** ( **光盘**)集成。

有了这个，让我们在我们的产品容器中添加一些数据并进行查询:

1.  We will add this entity based on the following sample JSON. Based on the product category, there could be different attributes.

    例如，如果产品类别为`Books`，则`Authors`、`Format`等字段中会有值；但是，如果类别是`Clothing`，则有诸如`Size`和`Color`等字段的值。这个模式可以在我们的电子商务应用程序中重用:

    ```
    {
      "Id": "Book.1",
      "Name": "Mastering enterprise application 
          development Book",
      "Category": "Books",
      "Price": 100,
      "Quantity": 100,
      "CreatedDate": "20-02-2020T00:00:00Z",
      "ImageUrls": [],
      "Rating": [
        {"Stars": 5, "Percentage": 95},
        {"Stars": 4, "Percentage": 5}
      ],
      "Format": ["PDF","Hard Cover"],
      "Authors": ["Rishabh Verma","Neha Shrivastava",
          "Ravindra Akela","Bhupesh Guptha"],
      "Size": [],
      "Color": []
    }
    ```

2.  现在，让我们创建**普通旧 CLR 对象** ( **POCOs** )可以序列化到前面的 JSON。我们需要两个类来表示它们:一个用于*产品*，一个用于*评级*，这是`Product`的子类。在带有核心(SQL) API 的 Azure Cosmos DB 中，任何实体的必备字段之一是`id`字段，它有点像主键。因此，我们的父模型有必要定义`id`字段。这些类如下所示:

    ```
    public class Rating{
        public int Stars { get; set; } 
        public int Percentage { get; set; } 
    }
    public class Product{
        [JsonProperty(PropertyName = "id")]
        public string ProductId { get; set; } 
        public string Name { get; set; } 
        public string Category { get; set; } 
        public int Price { get; set; } 
        public int Quantity { get; set; }
        public DateTime CreatedDate { get; set; }
        public List<string>  ImageUrls { get; set; }
        public List<Rating> Rating { get; set; } 
        public List<string> Format { get; set; } 
        public List<string> Authors { get; set; } 
        public List<int> Size { get; set; } 
        public List<string> Color { get; set; } 
    }
    ```

3.  现在，让我们创建以下`Product`类的对象，并将其插入数据库:

    ```
    Product book = new Product()
    {
        ProductId = "Book.1", Category = "Books", Price = 
        100,
        Name = "Mastering enterprise application 
        development Book",                    
        Rating = new List<Rating>() { new Rating { Stars = 
        5, Percentage = 95 }, new Rating { Stars = 4, 
        Percentage = 5 } },
        Format = new List<string>() { "PDF", "Hard Cover" },
        Authors = new List<string>() { "Rishabh Verma", "Neha Shrivastava", "Ravindra Akela", "Bhupesh Guptha" }
    };
    ```

4.  Now, we will call the `CreateItemAsync` method using the `productContainer` object, as shown in the following code snippet. Also, we should ensure that an object with the same `ProductId` value isn't already present:

    ```
    try
    {
        // Check if item it exists.  
        ItemResponse<Product> productBookResponse = await productContainer.ReadItemAsync<Product>(book.ProductId, new PartitionKey(book.Name));
    }
    catch (CosmosException ex) when (ex.StatusCode == System.Net.HttpStatusCode.NotFound)
    {
        ItemResponse<Product> productBookResponse = await productContainer.CreateItemAsync<Product>(book, new PartitionKey(book.Name));
        Console.WriteLine($"Created item {productBookResponse.Resource.ProductId}");
    }
    ```

    一旦我们运行了这段代码，数据就应该被插入到`Products`容器下的`Ecommerce`数据库中。

5.  如果我们想查询这个记录，我们可以使用下面的代码来查询数据库。如您所见，语法非常类似于从 SQL 数据库中查询数据:

    ```
    string getAllProductsByBooksCAtegory = "SELECT * FROM p WHERE p.Category = 'Books'";
    QueryDefinition query = new QueryDefinition(getAllProductsByBooksCAtegory);
    FeedIterator<Product> iterator = productContainer.GetItemQueryIterator<Product>(query);
    while (iterator.HasMoreResults)
    {
        FeedResponse<Product> result = await iterator.ReadNextAsync();
        foreach (Product in result)
        {
            Console.WriteLine($"Book retrived – 
            {product.Name}");
        }
    }
    ```

类似地，`ContainerClass`提供了可用于各种 CRUD 操作的所有相关方法。所有那些 api 都可以在这里找到:[https://docs . Microsoft . com/en-us/dotnet/API/Microsoft . azure . cosmos . container？view=azure-dotnet](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.cosmos.container?view=azure-dotnet) 。

在此基础上，我们将设计我们的电子商务应用所需的数据模型以及各种 API 要消费的相关数据服务层。到目前为止，我们已经看到了 SQL 和 NoSQL 提供程序。让我们看看还有哪些其他选项可以保存数据。

## 天青储

Azure Storage 是一个高度可用且可扩展的数据存储，支持以各种格式存储数据，包括文件。Azure Storage 主要支持以下四种类型的数据:

*   **Azure 表**:支持持久化无模式数据的 NoSQL 实现。
*   **Azure Blob**:Blob是非结构化数据，适用于需要上传、下载或流式传输大量文件的应用程序。
*   **Azure 队列**:这个允许你以任何可序列化的格式对消息进行排队，然后由服务进行处理。队列非常适合具有大量服务对服务通信的场景，并且充当消息的持久层。
*   **Azure 文件/Azure 磁盘**:用于文件的数据存储，非常适合基于本地文件应用编程接口构建的系统。

以下几点使 Azure 存储成为应用程序开发的重要组成部分之一:

*   **高可用性**:存储在 Azure Storage 中的数据为跨数据中心/区域的复制提供了开箱即用的支持，这进一步确保了一个区域的硬件故障不会导致数据丢失。
*   **性能**:对 CDN 集成的现成支持，有助于从离用户和更近的位置(边缘服务器)缓存和加载数据(尤其是静态文件)，进一步提高性能。除此之外，存储类型可以升级为高级存储，利用固态硬盘进一步加快磁盘输入/输出并提高性能。
*   **完全管理**:硬件由 Azure 完全管理，用于任何更新/维护。
*   **安全性**:磁盘上存储的所有数据都是加密的，对 Azure Storage 中数据的访问进一步支持私有、公共和匿名模式。
*   **现收现付**:和所有其他 Azure 服务一样，Azure Storage 也支持基于数据/运营规模的现收现付模式。

### Azure 存储帐户

让我们创建一个简单的控制台应用程序，将文件上传到 Blob 并从 Blob 下载文件。要与 Azure Storage 服务通信，先决条件是创建一个 Azure Storage 帐户，该帐户提供对所有 Azure Storage 服务的访问，并通过 Azure Storage 的唯一命名空间，使我们能够通过 HTTP/HTTPS 访问存储在 Azure Storage 中的数据。要创建 Azure 存储帐户，请执行以下步骤:

1.  Sign in to the Azure portal, click **Create resource**, and select **Storage Account**. This will open the **Create storage account** page. Fill in the details as shown in the following screenshot and click **Review + create**:

    ![Figure 9.8 – Creating an Azure Storage account ](Images/Figure_9.8_B15927.jpg)

    图 9.8–创建 Azure 存储帐户

    标准层有两个可能值的重要属性，对于**账户**类，我们有:

    *   **StorageV2(通用 v2)** :最新版本的账户类型，允许访问所有存储类型，如文件、blobs、队列等。这对于新创建的存储帐户更为可取。
    *   **存储(通用 v1)** :旧版本的账户类型，允许访问所有存储类型，如文件、博客、队列等。
    *   【blob 存储:只支持 blob 存储的账户类型。

另一个是**复制**，支持跨数据中心/区域的存储数据复制。以下屏幕截图显示了可能的值:

![Figure 9.9 – Replication options in an Azure Storage account ](Images/Figure_9.9_B15927.jpg)

图 9.9–Azure 存储帐户中的复制选项

1.  创建账户后，导航至**存储账户** | **键**。复制**连接字符串**值。
2.  创建新的。NET 5 控制台应用程序并安装`Azure.Storage.Blobs` NuGet 包。
3.  要将内容上传到 Azure Storage，我们需要首先创建一个容器。如果容器不存在，我们将使用`Azure.Storage.Blobs.BlobContainerClient`类及其`CreateIfNotExistsAsync`方法来创建容器。有了这个，更新`Main`方法，如下面的代码片段所示:

    ```
    static async Task Main(string[] args)
    {
                string connectionString = 
                "CONNECTION_STRING";
                string containerName = "fileuploadsample";
                string blobFileName = "sample.png";
                // Upload file to blob            
                BlobContainerClient containerClient = new 
                BlobContainerClient(connectionString, 
                containerName);
                await containerClient.CreateIfNotExists
                Async(PublicAccessType.None); 
                //Making blob private.
    }
    ```

4.  接下来，我们需要将文件上传到我们将使用`Azure.Storage.Blobs.BlobClient`的容器中，该容器将连接字符串、容器名称和 blob 名称作为输入参数。对于这个示例，我们正在将一个本地`sample.png`文件上传到 blob，我们将使用`FileStream`类读取该文件，并将其传递给`Azure.Storage.Blobs.BlobClient`类的`UploadAsync`方法。在`Main`方法中创建容器后，添加以下代码片段:

    ```
    BlobClient blobClient = new BlobClient(connectionString, 
    containerName, blobFileName);
    using FileStream fileStream = File.OpenRead(blobFileName);
    await blobClient.UploadAsync(fileStream, true);
    fileStream.Close();
    Console.WriteLine(blobClient.Uri.ToString());
    ```

在此阶段运行示例会将文件上传到 blob，并在命令行中显示 blob 网址。然而，如果我们试图访问该网址，它将无法访问，因为创建的 blob 是私有的。要访问私有 blobs，我们需要生成一个**共享访问签名** ( **SAS** )并将其作为查询字符串参数传递。为此，在`Main`方法中的上传代码后添加以下代码:

```
BlobSasBuilder sasBuilder = new BlobSasBuilder()
{
    BlobContainerName = containerClient.Name,
    Resource = "b", // c for container
    BlobName = blobClient.Name
};
sasBuilder.ExpiresOn = DateTimeOffset.UtcNow.AddHours(1);
sasBuilder.SetPermissions(BlobContainerSasPermissions.Read);
if (blobClient.CanGenerateSasUri)
{
    Uri blobSasUri = blobClient.GenerateSasUri(sasBuilder);
    Console.WriteLine(blobSasUri.ToString());
}
Console.ReadLine();
```

这里，我们使用`Azure.Storage.Sas.BlobSasBuilder`类来配置各种参数，如权限和到期时间，为上传的文件生成一个 SAS URI。最后，前面代码的输出如下图所示:

![Figure 9.10 – Blob upload output and Storage Explorer ](Images/Figure_9.10_B15927.jpg)

图 9.10–Blob 上传输出和存储资源管理器

这是一个利用 Azure Storage 上传文件的小示例。这可以作为一个应用编程接口进一步增强，最终可以用于文件上传和下载场景。对于我们的电子商务应用程序，我们将使用 Azure Blob 来存储产品的图像。

注意

有关 Azure 存储的更多高级概念和示例，请参考以下链接:

[https://docs . Microsoft . com/en-us/azure/storage/common/storage-account-overview](https://docs.microsoft.com/en-us/azure/storage/common/storage-account-overview)

[https://github . com/Azure/Azure-SDK-for-net/tree/master/SDK/storage/Azure。Storage.Blobs/samples](https://github.com/Azure/azure-sdk-for-net/tree/master/sdk/storage/Azure.Storage.Blobs/samples)

[https://docs . Microsoft . com/en-us/azure/cdn/cdn-create-a-storage-account-with-cdn](https://docs.microsoft.com/en-us/azure/cdn/cdn-create-a-storage-account-with-cdn)

在本节中，我们已经讨论了中可用的各种数据提供程序。NET 5。然而，简化持久化数据的一个重要库是 EF。让我们看看如何将 EF 集成到。NET 5 应用程序。

# 与英孚核心合作

EF Core 是一个 ORM，推荐给任何使用关系数据库作为数据存储的 ASP.NET Core 5 应用程序。早些时候，我们看到在 ADO.NET，我们必须创造`Connection`、`Command`和`Reader`物体。EF 通过提供抽象并允许开发人员编写应用程序代码来简化这个过程，并且像任何其他 ORM 一样，EF 帮助使用对象模型范式在数据库上执行各种操作。

配置 EF Core 就像安装所需的 NuGet 包一样简单，在`Startup`类中注入所需的服务，然后在需要的地方使用它们。作为这个过程的一部分，需要定义的关键类之一是数据库上下文，它需要继承`Microsoft.EntityFrameworkCore.DbContext`类。让我们看看如何在剩下的英孚核心配置中做到这一点。

## 配置和查询

英孚核心中的`DbContext`类保存了我们的应用程序与数据库通信所需的所有抽象，因此需要集成英孚核心的一个关键设置是定义我们特定于应用程序的上下文类。该类将主要保存`DbSet`类型的公共属性形式的所有 SQL 表/视图，如以下代码所示:

```
public virtual DbSet<Employee> Employees { get; set; }
```

这里，`Employee`是表示我们数据库中的表的 POCO 类。应用程序上下文类应该具有接受`DbContextOptions`或`DbContextOptions<T>`并将其传递给基类的参数化构造函数。

让我们基于 Razor Pages 和 SQLite 创建一个简单的 web 应用程序，并使用 EF Core 读取数据。对于此示例，我们将使用 SQLite 获取一个简单的员工数据库，该数据库包含具有以下数据模型的员工详细信息:

![Figure 9.11 – Employee database model ](Images/Figure_9.11_B15927.jpg)

图 9.11–员工数据库模型

如果你之前没有在剃刀页面工作过，那就不用担心；这是一个基于页面的框架，可用于在 ASP.NET 核心 5 中构建数据驱动的应用程序，并在 [*第 11 章*](11.html#_idTextAnchor228)*创建 ASP.NET 核心 5 网络应用程序*中进行了介绍。

现在，让我们按照以下步骤创建我们的应用程序:

1.  使用命令行中的以下命令创建一个新的 Razor Pages 应用程序，这会在`EmployeeEF`文件夹内创建一个新的 Razor Pages 应用程序:

    ```
    dotnet new webapp -o EmployeeEF
    ```

2.  Navigate to the `EmployeeEF` folder and open it in Visual Studio Code, and then install the following NuGet packages:

    `Microsoft.EntityFrameworkCore.Sqlite`、`Microsoft.EntityFrameworkCore.Design`

    前一个包是 SQLite 的 EF Core 提供程序，后一个包用于使用 EF Core 迁移创建基于 C# POCOs 的数据库。

3.  现在，添加`Models`文件夹并添加必要的 POCO 类，如下所示。这些类表示来自*图 9.11* :

    ```
        public class Employee
        {
            public int EmployeeId { get; set; }
            public string Name { get; set; }
            public string Email { get; set; }
            public ICollection<Address> Address { get; set; }
        }
        public class Address
        {
            public int AddressId { get; set; }
            public int EmployeeId { get; set; }
            public string City { get; set; }
            public Employee Employee { get; set; }
        }
    ```

    的数据库模式
4.  这里，数据库表中的所有列都表示为具有相关数据类型的属性。对于诸如外键之类的关系，创建子类型的属性，称为*导航属性*，该属性的类型由`ICollection`表示，而父类类型的另一个属性在子类中创建。例如，在前面的代码中，这在`public Icollection<Address> Addresses`和`public Employee Employee`属性中表示，这两个属性定义了`Employee`和`Address`表之间的外键约束。任何名为`ID`或`<class name>ID (EmployeeID)`的属性都会被自动视为主键。可以在`OnModelCreating`期间使用 Fluent API 或在`System.ComponentModel.DataAnnotations`中使用注释来进一步定义约束。有关模型创建的更多示例和详细信息，请参考[https://docs.microsoft.com/en-us/ef/core/modeling](https://docs.microsoft.com/en-us/ef/core/modeling)。
5.  添加一个继承自`Microsoft.EntityFrameworkCore.DbContext`的类，并命名为`EmployeeContext`。添加以下定义我们的数据库上下文的代码:

    ```
        public class EmployeeContext : DbContext
        {
            public DbSet<Employee> Employees { get; set;}
            public DbSet<Address> Addresses { get; set;}
             public EmployeeContext (DbContextOptions
             <EmployeeContext> options)
                : base(options)
            {
            }
            protected override void OnModelCreating
            (ModelBuilder modelBuilder)
            {
                modelBuilder.Entity<Employee>().ToTable
                ("Employee");
                modelBuilder.Entity<Address>().ToTable
                ("Address");
            }
        }
    ```

6.  在`appsettings.json`中添加连接字符串。当我们使用 SQLite 时，在数据源中指定文件名应该足够好。但是，这将根据提供商而改变:

    ```
      "ConnectionStrings": {
        "EmployeeContext": "Data Source=Employee.db"
      }
    ```

7.  现在，在`Startup`类中注入数据库上下文类，以便它在整个应用程序中可用。在这里，我们还传递连接字符串，并配置任何附加选项，如重试策略、查询日志记录等。在`ConfigureServices`方法中添加以下代码:

    ```
    Services.AddDbContext<EmployeeContext>(options =>
    { 
     options.UseSqlite(Configuration.GetConnectionString("EmployeeContext"));
    });
    ```

我们几乎完成了英孚核心的设置。现在，让我们创建一些可用于播种数据库的示例数据:

1.  为此，我们将在数据库上下文中创建一个扩展方法，并在启动时调用它。创建一个`DbContextExtension`类，并向其中添加以下代码。这段代码什么都不做但是在数据库中添加了一些记录:

    ```
        public static void SeedData(this EmployeeContext 
        context)
        {
            SeedEmployees(context);            
        }
        private static void SeedEmployees(EmployeeContext 
        context)
        {
            if (context.Employees.Any())
            {
                return;
            }
            var employees = new Employee[]
            {
                new Employee{EmployeeId = 1, Name = 
                "Sample1", Email="Sample@sample.com"},
                new Employee{EmployeeId = 2, Name = 
                "Sample2", Email="Sample2@sample.com"},
            };
            context.Employees.AddRange(employees);
            var adresses = new Address[]
            {
             new Address{AddressId = 1, City = "City1", 
             EmployeeId = 1},
             new Address{AddressId = 2, City = "City2", 
             EmployeeId = 1},
             new Address{AddressId = 3, City = "City1", 
             EmployeeId = 2},
            };
            context.Addresses.AddRange(adresses);
            context.SaveChanges();
        }
    ```

2.  打开`Startup`，在`Configure`方法中，添加以下代码，在应用启动时播种数据。由于我们在插入之前检查了雇员表，应用程序的多次运行不会覆盖数据:

    ```
    using (var serviceScope = app.ApplicationServices.GetService<IServiceScopeFactory>().CreateScope())
    {
                    using (var context = serviceScope.
                    ServiceProvider.GetRequiredService
                    <EmployeeContext>())
                    {
                            context.SeedData();
                    }
    }
    ```

3.  现在，运行`dotnet build`并修复任何构建错误。为了从我们的模型中生成数据库并填充数据库，我们需要在本地或全局安装`dotnet-ef`并运行如下迁移命令，这将生成`Migrations`文件夹，然后生成`Employee.db`文件，这是我们的 SQLite 数据库:

    ```
    Dotnet tool install –global dotnet-ef //Installing dotnet ef.
    Dotnet ef migrations add InitialCreate //Generate DB migrations.
    Dotnet ef database update //Update database.
    ```

4.  现在，到阅读`Employee`表，导航到`Index.cshtml.cs`并粘贴以下代码。这里我们正在注入`EmployeeContext`然后从员工表中读取数据:

    ```
    public class IndexModel : PageModel
        {
            private readonly EmployeeContext context;
            public IndexModel(EmployeeContext context)
            {
                this.context = context;
            }
             public Ilist<Employee> Employees { get; set; }
             public async Task OnGetAsync()
            {
                this.Employees = await this.context.
                Employees.Include(x => x.Addresses).
                AsNoTracking().ToListAsync();
            }
        }
    ```

5.  Update `Index.cshtml` with the following code, which loops through the employee records populated in the `Employees` property of `IndexModel` and displays them:

    ```
    <table class="table">
    <tbody>
        @foreach (var item in Model.Employees)
        {<tr>
                <td>@Html.DisplayFor(modelItem => 
                item.EmployeeId)</td>
                <td>@Html.DisplayFor(modelItem => 
                item.Name)</td>
                <td>@Html.DisplayFor(modelItem => 
                item.Email)</td>
                <td>
                    @foreach (var address in item.Address)
                    {
                        @Html.DisplayFor(modelItem => 
                        address.City) @Html.DisplayName(" 
                         ")
                    }
                </td>
            </tr>
        }
    </tbody>
    </table>
    ```

    运行这段代码后，我们可以在浏览器中看到以下输出:

![Figure 9.12 – Employee app output ](Images/Figure_9.12_B15927.jpg)

图 9.12–员工应用程序输出

类似地，`DbContext`类中还有其他可用的方法，如`Add()`、`Remove()`和`Find()`，来执行各种 CRUD 操作，还有方法，如`FromSqlRaw()`来执行原始 SQL 查询或存储过程。

这是一个非常简单的例子，它的主要目的是展示 EF Core 对于现实应用的能力。我们可以使用包含所有 CRUD 方法的通用存储库和特定存储库的存储库模式来对表执行专门的查询。此外，一个工作模式单元可以用于事务。

## 代码优先还是数据库优先

在之前的示例中，我们有新创建的概念验证操作系统，并由此生成了一个数据库，这种从概念验证操作系统生成数据库的方式被称为**代码优先方法**。正如定义所示，我们首先定义了概念验证操作系统，然后生成数据库。

然而，很多时候，尤其是在迁移场景中或者有专门数据库团队的情况下，我们需要从数据库表中生成概念验证操作系统。英孚核心通过**数据库优先方法**支持这样的场景，其中模型和应用程序数据库上下文类是从现有数据库生成的。从数据库模型生成概念验证操作系统的过程被称为**支架**。在这种方法中，我们可以使用。NET CLI 或 Visual Studio 中的包管理器控制台，并使用`Scaffold-DbContext`命令，该命令接受各种参数，如数据库连接字符串和应用程序数据库上下文类的名称，然后生成 EF Core 所需的所有必需类。

其余的配置与代码优先的方法相同。带有各种参数的示例脚手架命令如下所示:

```
Scaffold-DbContext "Data Source=.;Initial Catalog=Employee.DB;Trusted_Connection=True;" Microsoft.EntityFrameworkCore.SqlServer -Namespace Api.Data.Models -ContextNamespaceApi.Data -ContextDir Api.Data/Abstraction -Context EmployeeContext -Force
```

在这个命令中，我们正在读取一个数据库`Employee.DB`，生成`Namespace Api.Data.Models`内的所有模型，生成`Api.Data/Abstraction`内的上下文，并命名上下文`EmployeeContext`。在数据库优先中，类之间的关系是使用 Fluent API 定义的，而不是注释。

这里有一件事就是每次我们运行这个命令，所有的 POCOs 都会和应用上下文类一起被覆盖。其次，这个命令生成一个带有`protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)`方法的上下文类。仅当上下文类需要维护连接字符串和其他 EF Core 选项时，才需要此方法。然而，在大多数现实世界的应用程序中，连接字符串是在`appsettings.json`中维护的，而 EF Core 是在`Startup`类中配置的，因此可以删除该方法。

这意味着每次脚手架搭建之后都要进行清理，避免任何定制的更好方法是为我们的应用程序数据库上下文创建一个分部类，并在那里进行所有定制，例如为存储过程添加特定的模型或定义任何特定于应用程序的约束。这样，无论何时我们构建应用程序，定制都不会被覆盖，这仍然允许我们从数据库自动生成类。

选择数据库优先方法还是代码优先方法完全取决于开发团队，因为这两种方法各有利弊，并且没有任何特定的特性在一种方法中可用但在另一种方法中不可用。

注意

`Scaffold-DbContext`支持多参数；例如，您可以指定–一个模式，用于为模式生成概念验证操作，等等。详情请参考[https://docs . Microsoft . com/en-us/ef/core/management-schemas/scaffolding？tab = dotnet-core-CLI](https://docs.microsoft.com/en-us/ef/core/managing-schemas/scaffolding?tabs=dotnet-core-cli)。

基于这种理解，让我们在下一节中创建将在我们的企业应用程序中使用的数据访问服务。

# 使用 Azure Cosmos DB 设计数据访问服务

由于 NoSQL 数据库都是关于快速访问和高可伸缩性的，NoSQL 的模式是非规范化的，因此存在很大的数据冗余可能性。让我们将需求从 [*第 1 章*](01.html#_idTextAnchor014)*设计和架构企业应用程序*映射到各个实体。下图显示了体系结构中各种服务的快速更新:

![Figure 9.13 – Services in an e-commerce application ](Images/Figure_9.13_B15927.jpg)

图 9.13–电子商务应用程序中的服务

为了更容易理解，我们将在进入概念验证之前在 JSON 中表示实体:

*   **用户容器**:这个容器会保存所有的用户档案信息，比如姓名和地址。对于此容器，`Email`字段用作分区键:

    ```
    {
      "Id": "1",
      "Name": "John",
      "Email": "John@xyz.com",
      "Address":[{"Address1":"Gachibowli","City":
          "Hyderabad","Country":"India"}],
      "PhoneNumber":12345
    }
    ```

*   **产品容器**:产品容器用于浏览产品并保存相关字段，支持分类搜索和到货日期排序。该模式将是我们在前面的示例中使用的模式，并且`Name`字段用作分区键。
*   **订单容器**:订单容器将存储特定用户的所有历史订单及其状态。该容器将保存具有相关状态的购物车，并在下订单后更新状态。对于此容器，`Id`字段用作分区键:

    ```
    {
      "Id": "1",
      "UserId": "1",
      "Products": [{"Id":"1","Name": 
          "T-Shirt","Quantity": 1,"Price": 10}],
      "OrderStatus" : "Processed",
      "OrderPlacedDate" : "20-02-2020T00:00:00Z",
      "ShippingAddress": {"Address1":"Gachibowli",
          "City":"Hyderabad","Country":"India"},
      "TrackingId": 1,
      "DeliveryDate":"28-02-2020T00:00:00Z"
    }
    ```

*   **发票容器**:发票容器将保存与特定订单的发票相关的所有信息。对于此容器，`Id`字段用作分区键:

    ```
    {
      "Id": "1",
      "OrderId": "1",
      "PaymentMode": "Credit Card",
      "ShippingAddress": {"Address1":"Gachibowli",
          "City":"Hyderabad","Country":"India"},
      "SoldBy": {"SellerName": "Seller1",  "Email": 
         "seller@ecommerce.com", "Phone": "98765432"},  
      "Products": [{"Id":"1", "Name": "T-Shirt", "Quantity": 1, "Price": 10}]
    }
    ```

`Product`和`Order`的组合如下图所示:

![Figure 9.14 – E-commerce database model's Product and Order schema ](Images/Figure_9.14_B15927.jpg)

图 9.14–电子商务数据库模型的产品和订单模式

正如你看到的，所有 1:N 的关系都是通过将子项目嵌入一个数组来处理的。类似地，`Invoice`和`User`实体模式如下图所示:

![Figure 9.15 – E-commerce database model's Invoice and User schema ](Images/Figure_9.15_B15927.jpg)

图 9.15–电子商务数据库模型的发票和用户模式

在我们的企业应用程序中，我们将有一个服务与 Azure Cosmos DB 数据库交互。这项服务包括以下三个项目，下面将对此进行解释:

*   `Packt.Ecommerce.Data.Models`
*   `Packt.Ecommerce.DataStore`
*   `Packt.Ecommerce.DataAccess`

第一个项目是`Packt.Ecommerce.Data.Models`，它是一个. NET 标准 2.1 库，包含了我们所有与数据库通信的概念验证操作系统。正如前面所讨论的，所有的概念验证对象都有一个共同的`id`属性和前面章节中 JSON 模式中描述的其他属性。

小费

如果有示例 JSON，我们可以在 C#类生成工具中使用 JSON。

`Packt.Ecommerce.DataStore`是. NET Standard 2.1 库，是保存通用存储库和实体特定存储库的存储库层。这个项目中一个重要的类是`BaseRepository`，它有以下方法，每个方法调用`CosmosClient`类各自的方法:

*   `GetAsync(string filterCriteria)`:基于`filterCriteria`从容器中获取记录。如果`filterCriteria`为空，则检索该容器中的所有记录。
*   `GetByIdAsync(string id, string partitionKey)`:这个方法有助于通过容器的 ID 和分区键从容器中检索任何记录。
*   `AddAsync(Tentity entity, string partitionKey)`:这个方法允许我们将记录插入容器。
*   `ModifyAsync(Tentity entity, string partitionKey)`:这个方法允许我们在容器中`UPSERT`(如果有记录，修改，否则插入)一个记录。
*   `RemoveAsync(string id, string partitionKey)`:该方法允许从容器中删除记录。

由于在 Azure Cosmos DB 中，每个记录都由 ID 和分区键的组合唯一标识，因此所有这些方法都接受分区键和`id`。由于这是一个通用存储库，类的签名如下，这允许我们为应用程序传递任何 POCO，并在相应的容器上执行 CRUD 操作:

```
public class BaseRepository<Tentity> : IbaseRepository<Tentity>
where Tentity : class
```

所有这些方法都需要一个`Microsoft.Azure.Cosmos.Continer`对象，我们为其创建一个`readonly`私有成员，该成员在类的构造函数中初始化，如下所示:

```
        private readonly Container container;
        public BaseRepository(CosmosClient cosmosClient, 
        string databaseName, string containerName)
        {
            if (cosmosClient == null)
            {
                throw new Exception("Cosmos client is 
                 null");
            }
            this.container = cosmosClient.GetContainer
            (databaseName, containerName);
        }
```

现在，`CosmosClient`将通过依赖注入进入系统，并在`static`类中配置。作为最佳实践，建议在应用程序的生命周期中只有一个`CosmosClient`实例，以更好地重用连接。因此，我们将在 ASP.NET 核心 5 依赖注入容器中将其配置为单例。我们过一会儿再谈这个。

回到存储库层，`BaseRepository`在以下具体类中被继承，每个存储库代表一个相应的容器:

*   `ProductRepository`
*   `UserRepository`
*   `OrderRepository`
*   `InvoiceRepository`

以`ProductRepository`为例，它将具有以下实现，其中我们使用`Ioptions`模式传递`CosmosClient`的单例实例和附加属性:

```
    public class ProductRepository : 
    BaseRepository<Product>, IproductRepository
    {
        private readonly Ioptions<DatabaseSettingsOptions> 
        databaseSettings;
        public ProductRepository(CosmosClient, 
        Ioptions<DatabaseSettingsOptions> 
        databaseSettingsOption)
            : base(cosmosClient, databaseSettingsOption.
              Value.DataBaseName, "Products")
        {
            this.databaseSettings = databaseSettingsOption;
        }
    } 
```

所有的其他存储库将遵循类似的结构。每个存储库将实现自己的接口来支持依赖注入。

注意

这些存储库将随着我们应用程序实现的进展而发展。

下一个项目是`Packt.Ecommerce.DataAccess`，是一个以 Web API 为目标的项目。NET 5，并将主要拥有所有的控制器来公开我们的存储库。每个存储库都是与相应控制器的 1:1 映射。例如，会有`ProductsController`将`ProductRepository`方法公开为一个 REST 应用编程接口。所有控制器都将使用构造函数注入来实例化它们相应的存储库。`Packt.Ecommerce.DataAccess`中很重要的一点就是 Azure Cosmos DB 数据库的配置。各种控制器的设计将非常类似于`Packt.Ecommerce.Product`网络应用编程接口的设计，这将在 [*第 10 章*](10.html#_idTextAnchor202)*中讨论，创建 ASP.NET 核心 5 网络应用编程接口*。

首先，我们将在`appsettings.json`中有一个对应的部分，如下所示:

```
  "CosmosDB": {
    "DataBaseName": "Ecommerce",
    "AccountEndPoint": "",
    "AuthKey": ""
  }
```

注意

对于本地开发环境，我们将使用**管理用户机密**，这里解释一下:[https://docs . Microsoft . com/en-us/aspnet/core/security/app-Secrets？视图=aspnetcore-5.0 &选项卡=窗口](https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-5.0&tabs=windows)。我们将设置以下值:

```
{
  "CosmosDB:AccountEndPoint": "", //Cosmos DB End Point
  "CosmosDB:AuthKey": "" //Cosmos DB Auth key
}
```

注意

但是，一旦部署了服务，就应该使用 Azure Key Vault，如中的 [*第 6 章*](06.html#_idTextAnchor125)*配置中所述。净芯*。

我们将定义一个包含依赖注入映射的扩展类。这里显示了其中的一个片段:

```
    public static class RepositoryExtensions
    {
        public static IserviceCollection 
        AddRepositories(this IserviceCollection services)
        {
            services.AddScoped<IproductRepository, 
            ProductRepository>();
            return services;
        }
    }
```

类似地，所有的存储库都会被映射。然后，我们将通过在`ConfigureServices`方法中添加以下代码，在`Startup`类和 Azure Cosmos DB 配置中对此进行配置:

```
services.AddOptions();
services.Configure<DatabaseSettingsOptions>(this.Configuration.GetSection("CosmosDB"));
string accountEndPoint = this.Configuration.GetValue<string>("CosmosDB:AccountEndPoint");
string authKey = this.Configuration.GetValue<string>("CosmosDB:AuthKey");
services.AddSingleton(s => new CosmosClient(accountEndPoint, authKey));
services.AddRepositories();
```

一旦完成配置，该服务就可以在其他服务中使用，例如`Products`、`Orders`和`Invoice`。这个库将拥有所有必要的 REST APIs 来对各种实体执行 CRUD 操作。

这结束了对各种实体执行 CRUD 操作的数据访问服务的创建，所有操作都作为 API 公开。该服务将从我们将在 [*第 10 章*](10.html#_idTextAnchor202)*中开发的所有其他服务中调用，创建 ASP.NET 核心 5 网络应用编程接口*。

# 总结

在本章中，我们了解了中提供的各种持久性选项。NET 5，从处理文件和目录的 API 到数据库，如微软 SQL Server 和 Azure Cosmos DB。

我们还了解了表单、表单的重要性，以及如何在使用微软 SQL Server 时使用 EF Core 构建持久层。在此过程中，我们使用 Azure Cosmos DB SDK 为我们的电子商务应用程序构建了一个数据访问层。一些关键要点是我们在 SQL 和 NoSQL 之间做出的设计决策，以及我们如何用应用程序逻辑抽象数据层和用户界面层，以帮助您构建可扩展的企业应用程序。

在下一章中，我们将研究 RESTful APIs 的基础和 ASP.NET Core 5 Web API 的内部结构，并进一步为电子商务应用程序构建各种 RESTful 服务。

# 问题

1.  Say you are migrating an existing web application to use EF Core; however, there isn't any change in the database schema and an existing one can be used as is. What is the preferable mode to use EF Core?

    a.数据库优先

    b.代码优先

    c.两者

2.  If we are building a recommendation system for our e-commerce application and we are using Azure Cosmos DB, what API is best recommended in this scenario?

    a.核心应用编程接口

    b.蒙古应用编程接口

    c.卡珊德拉应用编程接口

    d.格雷林图形应用编程接口

3.  I created a container in SQL API-based databases to store user profile information and defined `Email` as the partition key. My system has 100 unique emails. How many logical partitions will my container have?

    a.1.

    b.0.

    c.100.

    d.Azure Cosmos DB 不支持逻辑分区。

4.  Which of the following classes is derived from the `TextWriter` class?

    a.`StreamWriter`

    b.`BinaryWriter`

    c.`XMLWriter`

# 进一步阅读

下面提供了一些链接来进一步理解本章的主题:

*   https://docs.microsoft.com/en-us/ef/core/saving/transactions
*   https://docs.microsoft.com/en-us/ef/core/performance/advanced-performance-topics
*   [https://docs.microsoft.com/en-us/aspnet/core/security/gdpr?view=aspnetcore-5.0](https://docs.microsoft.com/en-us/aspnet/core/security/gdpr?view=aspnetcore-5.0)