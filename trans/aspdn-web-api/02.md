# 第二章。 理解资源和面向服务的体系结构

软件架构是指一个系统的整体结构以及组成系统的实体和组件之间的相互关系。 有各种各样的架构风格，如面向对象的架构、面向服务的架构、面向云的架构和面向资源的架构。

**面向服务的****建筑**(**SOA)和【显示】面向资源架构**(**ROA)建筑设计模式,提供概念和必要的开发工具和技术来实现分布式应用程序的架构。 分布式体系结构由服务组成，客户机可以通过使用定义良好的接口通过网络使用这些服务。 客户端使用的这些组件是 ROA 中的命名资源和 SOA 中的服务。**

 **在本章中，我们将讨论面向资源架构的基础知识，以及它们与面向服务架构和面向对象架构的区别。 我们还将探讨设计和实现 ROAs 的最佳实践。

在本章中，我们将涵盖以下主题:

*   SOA
*   ROA
*   什么是资源导向?
    *   资源定位的概念
    *   可寻址能力
    *   无国籍
    *   表示
*   面向资源的服务和 REST
*   面向资源的服务和 web 服务
*   面向只读和读写资源的服务
*   指导方针和最佳实践

# 理解 SOA

SOA是一种体系结构范例，在这种范例中，您拥有一组松散耦合和可扩展的服务，每个服务都能够独立于另一个服务进行修改，从而保持服务集成的完整性。 SOA 由一组称为服务的离散软件模块组成。 这些服务可以与其他服务交换数据和信息。

请注意，SOA 体系结构范例基于企业业务体系结构的功能分解。 在此过程中，它引入了两个不同的高级抽象，即企业的业务服务和企业的业务流程。 业务服务代表企业的业务功能，而业务流程定义企业业务的功能。

SOA 可以使用以下技术之一实现:

*   Web 服务
*   Windows Communication Foundation
*   CORBA
*   DCOM
*   我
*   EJB

SOA 支持通过网络对松散耦合的分布式应用程序和服务进行出色的集成。 SOA 本质上是一组可以通信的服务。 请注意，web 服务、J2EE、CORBA 等实际上是 SOA 的实现。 面向服务的设计的最重要的好处包括以下几点:

*   平台和语言独立性
*   松散耦合
*   位置透明化，降低维护成本
*   随着时间的推移，支持无缝更新
*   更容易维护和无缝部署
*   SOA设计由许多元素组成，包括以下内容:
    *   服务
    *   服务提供者
    *   服务消费者
    *   服务注册中心
    *   服务合同

让我们更详细地看看每一个。

## 服务

可以将服务定义为定义良好的、自包含的和独立的业务功能的实现，该业务功能具有接受一个或多个请求并使用定义良好的标准接口返回一个或多个响应的能力。 服务独立于其实现所依赖的技术; 因此，服务的接口应该是平台独立的。 服务还应该具有在运行时动态发现和调用的能力。 服务将业务功能作为服务操作提供给服务使用者。

服务是用于实现企业架构的设计、实现和部署构件的单元。 服务是使用谓词定义的。 例如，验证客户的凭证; 这描述了它实现的业务功能。 服务实现以 RPC 样式或消息传递样式定义服务接口。 虽然前者使用服务调用技术，但后者执行服务语义中定义的服务操作。

## 服务提供商

服务提供者是提供服务的可网络寻址实体。 注意，在 SOA 中，服务提供者也可以是服务使用者。

## 服务消费者

服务使用者是通过在服务注册中心定位服务、绑定到服务、然后执行服务方法来消费(或使用)服务提供者提供的服务的实体。 服务使用者也称为服务客户机或简称为客户机。

## 服务注册表

服务注册中心是发布服务的基于网络的存储库。 在运行时，服务使用者使用该注册中心定位服务并绑定到它。 使用服务注册表的优点包括:

*   可伸缩性
*   松散耦合
*   热更新
*   动态服务查找

## 服务合同

服务契约是一个规范，它表示服务使用者将如何与特定服务的服务提供者交互。 下图说明了服务契约及其实现之间的关系

![Service contract](graphics/9748EN_02_01.jpg)

服务契约与服务实现之间的关系

## 服务代理

服务代理是对服务使用者端服务的引用——它由服务提供者提供以方便服务方法调用。 服务使用者或服务客户机使用此代理来调用一个或多个服务方法。

## 服务租赁

服务租期是预定义的持续时间，表示服务的生命周期。 这个意味着在某个时间之后服务将不再有效。 注意，当这个时间周期结束时，服务使用者应该请求服务注册中心授予一个新的服务租约，以便服务使用者能够重新获得对服务的访问权并执行服务方法。

## 消息

服务提供者和服务使用者通过消息进行通信。 因此，消息是服务提供者(即服务的提供者)和服务使用者(即服务的使用者)之间通信的媒介。 注意，这类消息本质上是以预定义的 XML 格式提供的。 除了 XML 格式外，它还可以是 JSON 格式或服务提供者和使用者共同同意的任何其他格式。 下图显示了一个服务通过使用消息与另一个服务进行通信

![Message](graphics/9748EN_02_02.jpg)

服务之间使用消息交换进行通信

## 服务描述

服务描述是一个规范，它包含了调用服务所必需的信息。 这些信息可能包括参数、约束和定义如何调用服务的策略。

## 广告与发现

广告和发现是 SOA 中两个最基本的属性。 尽管前者关系到服务发布其描述以便服务使用者定位的能力，但后者关系到服务使用者从服务注册中心发现已发布的服务并在必要时调用它们的能力。

## 从面向对象到 SOA 到 ROA 再到 REST

基于调用的分布式系统具有以下架构风格之一:

*   面向对象的体系结构
*   你的声音听起来
*   罗阿斯

面向对象的体系结构(T0)处理对象实例，并且通信是隐式有状态的。 状态信息存储在服务器端。 对对象实例的每次访问都涉及一次往返通信。

soa围绕服务及其暴露的端点展开。 由于 soa 的无状态特性，所以它是无状态且易于伸缩的。 REST 体系结构范例将世界上的所有实体视为连接的资源，并重用现有的 HTTP 基础设施。 缓存请求的能力、执行无状态交互的能力、可伸缩性、简单性、敏捷性和灵活性是该体系结构的一些优点。 然而，缺乏参考、缺乏工具支持以及缺乏适当的标准化是该体系结构的缺点。

服务确实有接口，并且可以在其生命周期内被引用。 它不一定有一个状态。 每个服务都有一个定义消息和有效负载格式的接口描述。 可以发现和动态绑定服务。 它是模块化的、自包含的、可互操作的、可寻址的和可通过网络定位的。 服务也可以由其他服务组成。 下图说明了服务使用者、服务提供者和服务代理之间的关系。

![From object orientation to SOA to ROA to REST](graphics/9748EN_02_03.jpg)

服务提供者、服务使用者和服务代理之间的关系

通过将服务发布到名为**service Broker (Registry)**的存储库中，服务对客户(服务使用者)可用。 **服务使用者**(服务客户端)定位服务，使用服务代理，然后使用服务代理实例调用一个或多个服务方法。下图显示了服务使用者如何与服务注册中心对话。

![From object orientation to SOA to ROA to REST](graphics/9748EN_02_04.jpg)

服务使用者使用服务代理与服务注册中心和服务提供者进行通信

ROAs是无状态的，以资源为中心。 每个资源都使用一个 URI 来标识。 您总是可以拥有相同资源的多个副本。 在面向资源的体系结构中，请求通常是无状态的:在一个请求和下一个请求之间没有链接。 使用动词管理资源生命周期，即 HTTP、PUT、HTTP、DELETE 等。

REST 服务比基于 soap 的 SOA 更容易实现。 另外，REST 服务支持更好的缓存、轻量级的请求和响应以及减少网络流量。

REST 约束是应用于 REST 体系结构风格的设计规则。 我们将在下一章进一步探讨这些设计限制。

这些REST约束是:

*   客户机-服务器
*   无状态的
*   缓存
*   接口/统一合同
*   分层系统
*   Code-On-Demand

SOA 和 ROA 是两个截然不同的体系结构范例。 在前者中，服务是被赋予重要性的。 然而，在后一种情况中，资源受到重视。 因此，在 SOA 中动词很重要，而在 ROA 中名词很重要。 在 ROA 中，用于资源生命周期管理的常用动词包括 PUT 和 DELETE。 我们将在本书的后面探讨这一点。

REST的关键原则如下:

*   资源应该有一个 ID
*   链接相关资源
*   使用标准方法
*   资源可以有多种表示形式
*   无状态通信

# 一看 ROA

ROA主要基于资源的概念。 资源是一种可分布的组件，可以通过标准的公共接口访问它。 每个资源都与包含 URL 的唯一标识符相关联。

ROA 的主要概念集中在资源上。 资源应该具有以下特点:

*   一个资源应该是唯一的，并且可能链接到其他相关的资源。
*   一个资源至少应该有一个表示。
*   资源应该有属性和模式，它应该是可访问的(通过它的地址)，并且它应该提供上下文。
*   资源应该有名称; 这用于唯一地标识资源。 使用 uri 标识资源。

虽然资源链接用于表示同一资源或另一资源的另一种表示，但资源接口用于提供访问资源和操作其状态信息的接口。 资源使用 uri 表示。 注意，如果数据可以使用 URI 表示，那么它就是一种资源。

资源和 uri 的例子如下:

*   [http://www.mysoftware.com/software/releases/1.0.0.1.zip](http://www.mysoftware.com/software/releases/1.0.0.1.zip)
*   [http://www.mysoftware.com/software/releases/1.0.0.2.zip](http://www.mysoftware.com/software/releases/1.0.0.2.zip)
*   [http://www.mystore.com/search/Books/NewBook](http://www.mystore.com/search/Books/NewBook)

没有两个资源可以是相同的，但是两个或更多的资源可以指向相同的数据。 下面是一个例子:

*   `http://www.packtpub.com/sales/2012/Q4`
*   `http://www.packtpub.com/sales/2012/Q3`

下图显示了资源、它的表示和它的 URI 之间的关系:

![A look at ROA](graphics/9748EN_02_05.jpg)

资源、表示和 URI 之间的关系

## ROAs 的基本性质

ROA 实现应该包含以下六个基本的属性:

*   **可寻址性**:这个表示通过 uri 共享数据和信息的能力。
*   **无状态**:这意味着基于 rest 的 web 服务上的每个请求都应该是自包含的。 为了实现这种无状态特性，对 RESTful 服务的所有调用都应该在每个请求中包含相关的应用程序状态位。
*   **连通性**:这意味着资源应该包含到相关资源的链接。
*   **表示**:一个资源可以有多个表示。 这些表示中的每一个都应该有类似的 uri。 实际上，URI 应该包含服务器生成所需表示的足够信息。 表示实际上是资源的描述。 资源的表示方式清楚地描述了它的状态信息。
    *   **资源链接**:这个是用来表示同一资源或另一资源的另一种表示。
    *   **资源接口**:使用来提供一个接口来访问资源并操作其状态信息。

### ROAs 的基本概念

ROA 实现应该包含的四个基本概念包括:

*   可寻址性:资源的可寻址性是它通过格式良好的 uri 公开其数据的能力。
*   无状态:这意味着每个 HTTP(而且，因为 HTTP 是无状态协议)请求都是完全隔离的。
*   连通性:连通性是一种资源与另一资源连接的能力。 从本质上说，它是使用到同类数据的链接来建立的。
*   统一接口:RESTful 服务应该具有由 HTTP 的主要方法(即 GET、PUT、POST、DELETE 等)定义的统一接口。 特定资源的两个或多个表示形式使用 uri 明确标识。

## HTTP 基本概念

在本节中，我们将讨论 HTTP 协议的基础知识。

下表显示了常见的 HTTP 方法及其目的:

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

方法名称

 | 

目的

 |
| --- | --- |
| `DELETE` | 用于删除资源 |
| `GET` | 这是用于请求资源的特定表示的 |
| `HEAD` | 这与`GET`相同，但是只检索头部而不检索正文 |
| `OPTIONS` | 这个用于检索资源支持的方法 |
| `POST` | 这个用于发布或提交资源要处理的数据 |
| `PUT` | 这是用于使用资源的特定表示创建或更新数据的 |

下表显示了 HTTP状态码及其用途:

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

状态码

 | 

描述

 |
| --- | --- |
| 100 | 信息 |
| 200 | 成功的 |
| 201 | 创建 |
| 202 | 接受 |
| 300 | 重定向 |
| 304 | 不修改 |
| 400 | 客户端错误 |
| 402 | 付款要求 |
| 404 | 没有找到 |
| 405 | 方法不允许 |
| 500 | 服务器错误 |
| 501 | 没有实现 |

HTTP重定向状态码:

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

状态码

 | 

描述

 |
| --- | --- |
| 300 | 多个选择 |
| 301 | 搬到永久 |
| 302 | 发现(临时重定向) |

HTTP错误状态码如下表所示:

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

状态码

 | 

描述

 |
| --- | --- |
| 400 | 坏的请求 |
| 401 | 未经授权的 |
| 403 | 被禁止的 |
| 404 | 未找到资源 |
| 405 | 方法不允许 |
| 408 | 请求超时 |
| 409 | 冲突 |
| 413 | 请求实体太大 |
| 415 | 不支持的媒体类型 |

HTTP服务器错误状态码如下表所示:

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

状态码

 | 

描述

 |
| --- | --- |
| 500 | 内部服务器错误 |
| 501 | 没有实现 |
| 503 | 服务不可用 |
| 505 | 不支持 HTTP 版本 |

下表列出了一些资源方法，以及如何使用 HTTP 协议实现它们:

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

方法名称

 | 

描述

 | 

HTTP 操作

 |
| --- | --- | --- |
| `createResource` | 此将创建一个新资源 | `PUT` |
| `getResourceRepresentation` | 这是用于检索特定资源表示的 | `GET` |
| `deleteResource` | 此删除资源 | `DELETE` |
| `modifyResource` | 此修改了资源 | `POST` |
| `getMetaInformation` | 此检索资源的元数据 | `HEAD` |

在下一节中，我们将探讨 ROA。 我们将讨论资源意味着什么、约束条件等等。

# 面向资源和面向服务的架构

SOA和 ROA 架构设计范例提供了一种构建健壮的分布式架构的方法。 实质上，ROA 是针对 RESTful 体系结构的一组特定指导方针。 ROA 是一种为资源互连提供支持的结构设计。 资源是可以使用 URI 标识的实体。 服务器、计算机、计算机设备、网页、脚本等等都是 ROA 上下文中的资源。 SOA 是面向动词的，而 ROA 是面向名词的。

ROAs涉及对特定资源实例的检索。 ROA 中的请求是无状态的。 资源生命周期管理动词包括`PUT`、`DELETE`、`GET`和`POST`。 在 ROA 中，您有一个维护资源集合的服务提供者。 该服务提供者公开了一些基本操作，如以下所示:

*   创造新资源
*   检索资源
*   修改的资源
*   删除的资源

下面是 RESTful 服务支持的核心操作列表:

*   **GET**:这是一个返回已识别资源状态的操作
*   **POST**:这是一个操作，用于更新特定的资源
*   **PUT**:操作用于创建一个新资源
*   **DELETE**:用于删除或销毁特定的资源

## 资源

roa 主要依靠资源发展。 资源是使用标准公共接口处理的分布式组件。 资源本质上是用名词来定义的。 雇员的雇佣合同就是资源的一个例子——它描述了资源所代表的数据。 请注意，一个资源可以与其他资源相关或链接。 ROA 基于这样一个原则:任何可以被分配统一资源标识符的实体都可以被称为资源。

### 注意事项

注意，没有两个资源可以是相同的，尽管它们可以指向相同的数据。 一个资源可以有一个或多个 uri。 例如，您可以在多个 uri 中使用相同的销售数据。

资源是通过以下方式识别的:

*   **资源名称**:这是标识资源的唯一名称
*   **资源表示**:此提供关于资源当前状态的元数据信息
*   **资源链接**:此是指向同一资源或其他资源的链接
*   **资源接口**:这是一个统一接口，用于评估资源和操作资源的状态

## 统一资源标识符

每个资源都有自己的 URI 来标识。 URI 是资源的名称和地址。 uri 应该是描述性的，如下所示:

`http://www.packtpub.com/sales/2012/Q4`

`http://www.packtpub.com/sales/2012/Q3`

### 注意事项

注意，一个资源可以有一个或多个 uri。 例如，2012 年第四季度销售数据的细节也可以通过不同的 URI 获得，如下所示:

`http://www.packtpub.com/sales/2012/Q4`

`http://www.packtpub.com/sales/year/2012/Q4`

在前面的示例中，两个 uri 都指向相同的资源。

## 可寻址性

可寻址性是每个 ROA 的一个有趣的方面。 如果应用程序将其数据作为资源公开，我们可以说它是可寻址的。 现在，ROA 中的资源使用 uri 公开。 因此，我们可以说，为了使应用程序具有可寻址性，它应该通过 uri 公开其数据。

## 无国籍

无状态性是 ROA 的另一个重要方面。 这意味着每个 HTTP 请求都是隔离的，即在完全隔离的情况下发生。

## 表象

表示被定义为描述资源当前状态的一些数据。 例如，当 web 服务器以一系列字节的形式发送数据时，它就是资源的表示。

# 三种建筑风格的比较

在选择适合您的业务需求的体系结构风格时，有很多地方需要考虑。 下表比较了不同的建筑风格:

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

属性

 | 

面向对象的

 | 

面向资源的

 | 

面向服务的

 |
| --- | --- | --- | --- |
| **粒度** | 对象实例 | 资源实例 | 服务实例 |
| **缓存响应** | 没有 | 是的 | 没有 |
| **有效载荷** | 是的，它通常是特定于中间件的 | 不，你没有任何链接到特定的地址或 URL | 是的，WSDL 模式 |
| **寻址或请求路由** | 独特的对象实例 | 特定资源的唯一地址 | 服务的端点地址 |
| **服务器与客户端之间的耦合** | 由于对象序列化和早期绑定到接口而产生的紧密耦合 | 由于延迟绑定到资源数据而导致的松散耦合 | 由于延迟绑定到服务接口而产生的松散耦合 |

当服务器和客户端组件之间的耦合或内聚非常紧密时，OOA 最适合，因此最适合于封闭系统。

面向服务的架构涉及客户端和服务器组件之间的松散耦合，这是由于后期绑定到服务接口。 这些系统非常灵活，而且由于它们的无状态特性，易于扩展。 这些体系结构最适合于可以跨组织边界工作的共享系统。 下图展示了面向服务架构和面向对象架构的比较:

![Comparison of the three architectural styles](graphics/9748EN_02_06.jpg)

SOA 和 OOA 的比较

面向资源的系统涉及服务器和客户机组件之间的松散耦合，它们最适合于需要资源数据的后期绑定和缓存能力的场景。 由于它们的无状态特性，这些系统是可伸缩的。

从本质上讲，ROA 是一种架构范例，它基于四个基本概念:资源、资源的名称、资源的表示以及资源之间的链接。 它还基于四个不同的属性:可寻址性、无状态性、连通性和统一接口。

选择正确的体系结构风格完全取决于您的业务需求。 从本质上讲，您可以设计一个 web 服务应用程序，它可以将体系结构风格与面向资源的方法相结合，用于简单的数据读取，并将面向服务的方法用于复杂的数据操作。

### 注意事项

你可以参考以下网址:

[http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)

# 总结

在 OOP 中，重点是创建同时包含状态和行为的对象。 相反，SOA 构建在 OOP 之上，并允许您创建可重用的服务。 OOP 侧重于应用程序所包含的内容，而 SOA 侧重于应用程序的功能。 ROA 基于资源的概念。 服务表示所请求操作的执行，而资源表示给定数据类型的特定实例的数据访问机制。 资源是通过标准的公共接口处理的分布式组件。 资源可以使用 uri 寻址。

本章描述了与 ROA、web 服务和 SOA 相关的基本概念。 它介绍了 ROA，以及它与其他当代架构风格(如 OOP 和 SOA)的不同之处。 我们讨论了这三种架构范例的不同之处，以及 ROA 的概念。

在下一章中，我们将把这些概念付诸实践，讨论 RESTful web 服务的概念和特征，并探索如何使用 WCF 设计和实现 RESTful 服务。**